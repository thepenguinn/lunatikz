#!/usr/bin/env lua

local function tb_log(lvl, msg)
    if lvl == "warn" then
        print("WARN: " .. msg)
    elseif lvl == "log" then
        print("LOG: " .. msg)
    end
end

-- Param: file_path, absolute or relative path
local function check_file(file_path)
    local fd

    fd = io.open(file_path, "r")

    if fd then
        fd:close()
        return true
    else
        return false
    end

end

local function read_file(file)

    assert(
        type(file) == "string",
        "read_file: file is not a string"
    )

    local fd = io.open(file, "r")
    local source

    if fd then
        source = fd:read("a")
        fd:close()
        return source
    else
        return nil
    end

end

-- Param: root_dir string, path to the root dir
-- Return: a table
local function read_dep_cache(root_dir)

    local dep_file = io.open(root_dir .. "/.lunatikz/dep_cache", "r")
    local dep_cache = nil

    if dep_file then
        dep_file:close()
        local dep = dofile(root_dir .. "/.lunatikz/dep_cache")
        if dep then
            dep_cache = dep
        end
    end

    dep_cache = dep_cache or {}

    local mt_for_child = {
        __index = function (tbl, key)
            if key == "parent_nodes"
                or key == "child_nodes" then
                local val = {}
                rawset(tbl, key, val)
                return val
            end
        end
    }

    local mt = {
        __newindex = function (tbl, key, val)
            rawset(tbl, key, val)
            if type(val) == "table" then
                setmetatable(val, mt_for_child)
            end
        end
    }

    setmetatable(dep_cache, mt)

    for _, tbl in pairs(dep_cache) do
        if type(tbl) == "table" then
            setmetatable(tbl, mt_for_child)
        end
    end

    return dep_cache

end

local function read_subfix_cache(root_dir)

    local subfix_file = io.open(root_dir .. "/.lunatikz/subfix_cache", "r")
    local subfix_cache = nil

    if subfix_file then
        subfix_file:close()
        subfix_cache = dofile(root_dir .. "/.lunatikz/subfix_cache")
    end

    subfix_cache = subfix_cache or {}

    return subfix_cache

end

--  absolute path
local function write_config(path, config)

    -- TODO: this will fail if a table has both numbers and strings
    -- as their index, fix that.
    local function pairs_ordered(tbl)
        local idx_tbl = {}

        for key, _ in pairs(tbl) do
            idx_tbl[#idx_tbl + 1] = key
        end

        table.sort(idx_tbl)

        local idx = 0
        return function ()
            idx = idx + 1
            return idx_tbl[idx], tbl[idx_tbl[idx]]
        end

    end

    local function writetable(fd, tbl, depth)

        for key, child in pairs_ordered(tbl) do
            if type(child) == "table" then
                for i = 0, depth do
                    fd:write("    ")
                end
                if type(key) == "string" then
                    fd:write("[\"" .. key .. "\"] = {\n")
                else
                    fd:write("{\n")
                end
                writetable(fd, child, depth + 1)
                for i = 0, depth do
                    fd:write("    ")
                end
                fd:write("},\n")
            else
                for i = 0, depth do
                    fd:write("    ")
                end
                if type(key) == "string" then
                    fd:write("[\"" .. key .. "\"] = ")
                end
                if type(child) == "string" then
                    local str = child:gsub("\"", "\\\"")
                    fd:write("\"" .. str .. "\",\n")
                else
                    fd:write(tostring(child) .. ",\n")
                end
            end
        end
    end

    local file_fd = io.open(
        path,
        "w"
    )

    assert(file_fd,
        "Couldn't open "
        .. path
        .. " to write config"
    )


    file_fd:write("return {\n")
    writetable(file_fd, config, 0)
    file_fd:write("}\n")

end

-- Param: file_list a table of paths, should be relative paths from root_dir.
-- Return: a hashmap with each file name without extention as keys to tables,
--         and each having the parent_dir(string), and lmodt(nummer) as values
local function get_pics_list(root_dir, file_list, pics_list)

    assert(type(pics_list) == "table",
        "get_pics_list: expected pics_list to be a table"
    )

    -- Param: end_pics_data = {
    --              file_list = { -- a table
    --                  parent_dir = path of the parent dir,
    --                  file_name = name of the file
    --              },
    --              pics_list[key] = { -- a hashmap -- key = file name without extention
    --                  parent_dir = path of the parent dir,
    --                  lmodt = last modified time of tex file
    --              },
    --              read_files[key] = true -- a hashmap -- key = path of read files
    --        }
    -- Return: a hashmap with each file name without extention as keys to tables,
    --         and each having the parent_dir(string), and lmodt(nummer) as values
    local function _get_pics_list(end_pics_data)

        local child_file_list = {}

        for _, file in pairs(end_pics_data.file_list) do

            local file_path = file.abs_parent_dir .. "/" .. file.file_name

            if end_pics_data.read_files[file_path] then
                goto continue
            end

            end_pics_data.read_files[file_path] = true

            local file_fd = io.open(file_path, "r")
            assert(file_fd, "Invalid file path " .. file_path)

            -- stripping comments
            -- this works, kind of...
            local file_source = file_fd:read("a")
                :gsub("(\\\\)%%[^\n]-\n", "%1\n")
                :gsub("([^\\])%%[^\n]*", "%1")
                :gsub("^%%[^\n]*", "")

            local is_abs_path
            local parent_dir
            local file_name
            local is_dir
            local file_basename
            local has_extention

            local function process_includegraphics(fstarg)

                is_abs_path, parent_dir, file_name, is_dir =
                fstarg:match("^(/?)(.-)/-([%w%.-_ ]+)(/?)$")

                assert(not (is_dir == "/"), "File name ends with a /")

                file_basename = file_name:match("(.-)%.[%w-_]+ *$")
                assert(file_basename, "File basename is empty")

                end_pics_data.pics_list[file_basename] = true

            end

            for macro, fstarg in file_source:gmatch(
                "\\([%w-_]+)[ \n\t]*{(.-)}"
            ) do

                if macro == "subfile"
                    or macro == "subfileinclude"
                    or macro == "include"
                    or macro == "input" then

                    is_abs_path, parent_dir, file_name, is_dir =
                    fstarg:match("^(/?)(.-)/-([%w%.-_ ]+)(/?)$")

                    assert(not (is_dir == "/"), "File name ends with a /")

                    has_extention = file_name:match(".*%.(.-)$")

                    if not has_extention then
                        tb_log("log",
                            "get_pics_list: " .. fstarg .. " doesn't have any extentions,"
                            .. " appending .tex"
                        )
                        file_name = file_name .. ".tex"
                    end

                    if is_abs_path == "/" then
                        if parent_dir == "" then
                            child_file_list[#child_file_list + 1] = {
                                abs_parent_dir = "/",
                                file_name = file_name
                            }
                        else
                            child_file_list[#child_file_list + 1] = {
                                abs_parent_dir = "/" .. parent_dir,
                                file_name = file_name
                            }
                        end

                    else
                        if parent_dir == "" then
                            child_file_list[#child_file_list + 1] = {
                                abs_parent_dir = file.abs_parent_dir,
                                file_name = file_name
                            }
                        else
                            child_file_list[#child_file_list + 1] = {
                                abs_parent_dir = file.abs_parent_dir .. "/" .. parent_dir,
                                file_name = file_name
                            }
                        end
                    end

                elseif macro == "includegraphics" then
                    process_includegraphics(fstarg)
                end

                ::continue::
            end

            for fstarg in file_source:gmatch(
                "\\includegraphics[ \n\t]*%[.-%][ \n\t]*{(.-)}"
            ) do

                process_includegraphics(fstarg)
            end

            file_fd:close()

            ::continue::
        end

        if #child_file_list ~= 0 then
            end_pics_data.file_list = child_file_list
            return _get_pics_list(end_pics_data)
        end

    end

    return _get_pics_list({
        file_list = file_list,
        pics_list = pics_list,
        read_files = {}
    })

end

-- Param: file_path, absolute file path
-- Param: root_dir, project root directory (absolute)
-- Return: main_file(string) relative to root_dir
local function get_main_file(root_dir, file_path)

    assert(type(file_path) == "string",
        "get_main_file: Expected file_path to be string type"
    )

    local file_source

    local oparg
    local fstarg

    local oafile_name

    file_source = read_file(file_path)

    assert(file_source, "get_main_file: Failed to open, " .. file_path)

    oparg, fstarg = file_source:match(
        "\\documentclass[ \n\t]*%[(.-)%][ \n\t]*{(.-)}"
    )

    if fstarg == "subfiles" then

        oafile_name = oparg:match("^/?.-/-([%w%.-_ ]+)$")

        -- checking of extention
        if not oafile_name:match(".-%.([%w-_]+) *$") then
            -- if not adding one
            oafile_name = oafile_name .. ".tex"
        end

        -- lets assume the oafile_name is the main.file name
        -- \documentclass [../../main.tex] {subfiles}
        --                       ^      ^
        --                       |      |
        --                       +------+---- oafile_name
        return oafile_name
    else
        -- first argument is not subfiles then the file must be the main file
        return file_path:gsub("^" ..  root_dir, "")
    end

end

-- Param: file_path, relative path of file from current
--        working directory
-- Return: parent_dir(string), file_name(string)
local function split_path(file_path)

    local parent_dir
    local file_name
    local is_dir

    parent_dir, file_name, is_dir =
    file_path:match("^(/?.-)/-([%w%.-_ ]+)(/?)$")
    assert(not (is_dir == "/"), "File name ends with a /")

    assert(not (file_name == ""),
        "split_path: Got a file_name with empty string"
    )

    if parent_dir == "" then
        parent_dir = "."
    end

    return parent_dir, file_name

end

local function get_dep_list_from_dir(root_dir, pics_directory, dep_list)

    assert(pics_directory and pics_directory ~= "",
        "get_dep_list_from_dir: pics_directory is empty"
    )

    assert(type(dep_list) == "table",
        "get_dep_list_from_dir: pics_directory is empty"
    )


    local function add_files(dir, dep_list)

        local files_fd
        local lmodt_fd
        local lmodt

        local parent_dir
        local file_basename

        files_fd = io.popen(
            "find "
            .. dir
            .. " -type f -name \"*.tex\""
        )

        for file in files_fd:lines() do

            parent_dir, file_basename = file:match(
                "^(/?.-)/-([%w%.-_ ]+)%.tex$"
            )

            lmodt_fd = io.popen(
                "stat --printf \"%Y\" "
                .. file
            )

            lmodt = tonumber(lmodt_fd:read("a"))

            lmodt_fd:close()

            dep_list[file_basename] = {
                parent_dir = parent_dir,
                lmodt = lmodt
            }

        end

        files_fd:close()
    end

    local read_dirs = {}
    local dirs_fd

    dirs_fd = io.popen(
        "find "
        .. root_dir
        .. " -type d -name \"" .. pics_directory .. "\""
    )

    for dir in dirs_fd:lines() do
        if read_dirs[dir] then
            goto continue
        end
        add_files(dir, dep_list)

        read_dirs[dir] = true
        ::continue::
    end

    dirs_fd:close()

    -- for _, dir_list in pairs(dirs_to_add) do

    --     for _, dir in pairs(dir_list) do

    --         if read_dirs[dir.parent_dir] then
    --             goto continue
    --         end

    --         add_files(dep_list, dir.parent_dir)

    --         read_dirs[dir.parent_dir] = true
    --         ::continue::
    --     end

    -- end

end

local function build_dep_for_file(
    root_dir, cur_dir, key, style, dep_list, dep_cache, subfix_cache, updated_subfix_files
)

    assert(type(root_dir) == "string")
    assert(type(cur_dir) == "string")

    assert(type(key) == "string")
    assert(type(style) == "string")
    assert(type(dep_list) == "table")
    assert(type(dep_cache) == "table")

    assert(
        not dep_list[key].been_here,
        "cyclic referencing in dependency tree of "
        .. key
    )

    local file_fd
    local file_source
    local need_to_build = false
    local new_parent_nodes = {}

    if dep_list[key].dep_added then

        -- TODO: this check seems redundant, because if dep_list[key].dep_added
        -- then this must a from_child call.
        if dep_list[key].from_child then

            if not dep_cache[key]["build_child_nodes"] then
                dep_cache[key]["build_child_nodes"] = {}
            end

            if not dep_cache[key]["build_child_nodes"][style] then
                dep_cache[key]["build_child_nodes"] = {
                    [style] = {}
                }
            end

            dep_cache[key]["build_child_nodes"][style][
            dep_list[key].from_child
            ] = true

        end
        return dep_list[key].need_to_build
    end

    -- returns a boolean indicating whether to rebuild or not
    -- and the subfix_files itself, if its not empy.
    local function build_subfix_files(
        subfix_iter, subfix_files, subfix_cache, updated_subfix_files
    )

        local subfix_need_to_build = false
        local lmodt
        local hash
        local tmp_fd

        subfix_files = subfix_files or {}

        if not subfix_iter then
            tb_log("warn", "nil iter for key")
            return subfix_need_to_build, nil
        end

        for subfix_path in subfix_iter do

            if updated_subfix_files[subfix_path] then
                tb_log("log", "already updated: " .. subfix_path)
                subfix_files[subfix_path] = true
                if updated_subfix_files[subfix_path] == "mod" then
                    subfix_cache[subfix_path]["build_child_nodes"][style][key] = true
                    subfix_need_to_build = true
                end
                goto continue
            end

            -- checking for file's existence
            if not check_file(
                root_dir .. "/" .. subfix_path
            ) then
                tb_log(
                    "warn",
                    "File seems like doesn't exists: \""
                    .. root_dir .. "/" .. subfix_path .. "\""
                )
                goto continue
            end

            -- getting lmodt
            tmp_fd = io.popen(
                "stat --printf \"%Y\" \""
                .. root_dir .. "/" .. subfix_path .. "\""
            )
            assert(tmp_fd, "build_subfix_files: 'stat' failed.")
            lmodt = tonumber(tmp_fd:read("a"))
            tmp_fd:close()

            -- if any of these is not present in the subfix_cache then
            -- we need to build.
            if not subfix_cache[subfix_path] then
                subfix_cache[subfix_path] = {}
                subfix_need_to_build = true
            end
            if not subfix_cache[subfix_path]["build_child_nodes"] then
                subfix_cache[subfix_path]["build_child_nodes"] = {}
                subfix_need_to_build = true
            end
            if not subfix_cache[subfix_path]["build_child_nodes"][style] then
                subfix_cache[subfix_path]["build_child_nodes"][style] = {}
                subfix_need_to_build = true
            end
            if not subfix_cache[subfix_path]["build_child_nodes"][style][key] then
                subfix_cache[subfix_path]["build_child_nodes"][style][key] = true
                subfix_need_to_build = true
            end

            if subfix_cache[subfix_path]["lmodt"] then
                if subfix_cache[subfix_path]["lmodt"] >= lmodt then
                    tb_log("log", "not modified: " .. subfix_path)
                    updated_subfix_files[subfix_path] = "nomod"
                    subfix_files[subfix_path] = true
                    goto continue
                else
                    tb_log("log", "subfix_file modified: " .. subfix_path)
                end
            else
                subfix_cache[subfix_path]["lmodt"] = 0
                subfix_cache[subfix_path]["hash"] = ""
            end

            -- getting hash
            tmp_fd = io.popen(
                "sha256sum \""
                .. root_dir .. "/" .. subfix_path .. "\""
            )
            assert(tmp_fd, "build_subfix_files: 'sha256sum' failed.")
            hash = tmp_fd:read("a")
            hash = hash:match("^[^ ]*")
            tmp_fd:close()

            if subfix_cache[subfix_path]["hash"] == hash then
                tb_log("log", "subfix_file hash not changed: " .. subfix_path)
                subfix_cache[subfix_path]["lmodt"] = lmodt
                updated_subfix_files[subfix_path] = "nomod"
                subfix_files[subfix_path] = true
                goto continue
            else
                tb_log("log", "subfix_file hash changed: " .. subfix_path)
            end

            -- if we are here it means that the subfix file has modified and
            -- need to rebuild its every child node
            -- purge the build_child_nodes of subfix file then rebuild it back
            subfix_cache[subfix_path]["lmodt"] = lmodt
            subfix_cache[subfix_path]["hash"] = hash
            -- the build_child_nodes will be filled from above.

            subfix_files[subfix_path] = true
            subfix_need_to_build = true

            updated_subfix_files[subfix_path] = "mod"

            ::continue::
        end

        if not next(subfix_files, nil) then
            subfix_files = nil
        end

        return subfix_need_to_build, subfix_files

    end

    local function subfix_from_file_iter(root_dir, file_source, key_parent_dir)

        local tmp_fd
        local _iter = file_source:gmatch(
            "\\subfix[ \n\t]*{[ \n\t]*(.-)[ \n\t]*}"
        )

        -- strips the last directory from the parent_dir
        -- this will be absolute path
        local parent_dir = key_parent_dir:gsub("/-[^/]*$", "")

        -- this will return the subfix_path as the relative
        -- path from the root directory of the project.
        local function iter()

            local subfix_path = _iter()

            if not subfix_path then
                return nil
            end

            subfix_path = parent_dir .. "/" .. subfix_path

            tmp_fd = io.popen(
                "readlink -e \"" .. subfix_path .. "\""
            )
            assert(tmp_fd, "subfix_from_file_iter: 'readlink' failed.")
            subfix_path = tmp_fd:read("a")
                :gsub("\n", "")
                :gsub("^" .. root_dir .. "/", "")

            tmp_fd:close()

            return subfix_path

        end

        return iter

    end

    local function subfix_from_table_iter(subfix_files)

        local prev_idx = nil

        local function iter()

            prev_idx = next(subfix_files, prev_idx)
            return prev_idx

        end

        return iter

    end

    local function erase_build_child_nodes(child_nodes)

        if type(child_nodes) ~= "table" then
            return
        end

        for child in pairs(child_nodes) do

            erase_build_child_nodes(dep_cache[child]["child_nodes"])

            dep_cache[child]["build_child_nodes"] = nil
        end

    end

    if not dep_cache[key]
        or not dep_cache[key].lmodt
        or dep_cache[key].lmodt < dep_list[key].lmodt then

        if not dep_cache[key] then
            tb_log("log", "no dep_cache: " .. key)
        elseif not dep_cache[key].lmodt then
            tb_log("log", "no lmodt: " .. key)
        elseif dep_cache[key].lmodt < dep_list[key].lmodt then
            tb_log("log", "file modified: " .. key)
        end

        -- each of these parent_node will have the key as
        -- one of their child_nodes, but we don't need to
        -- erase those since we won't ever be climbing down
        -- from a parent node to its child_nodes.
        -- So only erasing the the parent_nodes table

        -- TODO: Something is wrong here fix it
        --
        if dep_cache[key] then
            dep_cache[key]["parent_nodes"] = nil
            -- for subfix
            dep_cache[key]["subfix_files"] = nil
        end

        need_to_build = true

        file_source = read_file(
            dep_list[key].parent_dir
            .. "/"
            .. key
            .. ".tex"
        )

        for macro in file_source:gmatch(
            "\\([%w%-_]+)[ \n\t]*{[^}]-}[ \n\t]*{[^}]-}"
        ) do

            if dep_list[macro] then

                dep_list[key].been_here = true

                new_parent_nodes[#new_parent_nodes + 1] = macro

                dep_list[macro].from_child = key
                build_dep_for_file(root_dir, cur_dir, macro, style, dep_list, dep_cache, subfix_cache)
                dep_list[macro].from_child = nil

                dep_list[key].been_here = nil

            else
                tb_log("log",
                    "Skipping macro: because no tex file named "
                    .. macro
                    .. ".tex found"
                )
            end

        end

        dep_cache[key] = dep_cache[key] or {}

        _, dep_cache[key]["subfix_files"] = build_subfix_files(
            subfix_from_file_iter(root_dir, file_source, dep_list[key].parent_dir),
            nil, subfix_cache, updated_subfix_files
        )
        dep_cache[key].lmodt = dep_list[key].lmodt

        if dep_cache[key].parent_nodes then
            for parent in pairs(dep_cache[key].parent_nodes) do
                dep_cache[parent].child_nodes[key] = nil
            end
        end

        for _, parent in pairs(new_parent_nodes) do
            if not dep_cache[parent] then
                -- this assert will never get triggered
                assert(dep_list[parent],
                    "build_dep_for_file: couldn't find "
                    .. parent
                )
                dep_cache[parent] = {
                    lmodt = nil
                }
            end
            dep_cache[key].parent_nodes[parent] = true
            dep_cache[parent].child_nodes[key] = true
        end

        erase_build_child_nodes(dep_cache[key]["child_nodes"])
        dep_cache[key]["build_child_nodes"] = nil

        if dep_list[key].from_child then
            dep_cache[key]["build_child_nodes"] = {
                [style] = {
                    [dep_list[key].from_child] = true
                }
            }
        end

    else

        local parent_need_to_build = false
        local child_need_to_build = false
        local subfix_need_to_build = false

        local subfix_files = nil

        -- check if any of the subfix files have changed.
        if dep_cache[key]["subfix_files"] then

            subfix_need_to_build, subfix_files = build_subfix_files(
                subfix_from_table_iter(dep_cache[key]["subfix_files"]),
                nil, subfix_cache, updated_subfix_files -- TODO
            )

            if subfix_need_to_build then
                -- we need to rebuild all the child_nodes of this nodes
                -- so erasing all the build_child_nodes.
                erase_build_child_nodes(dep_cache[key][child_nodes])
                dep_cache[key]["build_child_nodes"] = nil
            end
        end

        if dep_list[key].from_child then

            if not dep_cache[key]["build_child_nodes"] then
                dep_cache[key]["build_child_nodes"] = {}
            end

            if not dep_cache[key]["build_child_nodes"][style] then
                dep_cache[key]["build_child_nodes"][style] = {}
            end

            if not dep_cache[key]["build_child_nodes"][style][
            dep_list[key].from_child
            ] then
                child_need_to_build = true

                dep_cache[key]["build_child_nodes"][style][
                dep_list[key].from_child
                ] = true
            end
        end

        for parent in pairs(dep_cache[key].parent_nodes) do
            -- TODO: this is kinda redundant, because this
            -- will add ["build_child_nodes"] to every
            -- node that is a parent, we just need to be added
            -- to the parent just above the end pics.
            dep_list[parent].from_child = key
            parent_need_to_build = build_dep_for_file(
                root_dir, cur_dir, parent, style, dep_list, dep_cache, subfix_cache
            )
            dep_list[parent].from_child = nil

            if parent_need_to_build then

                if not dep_cache[parent]["build_child_nodes"] then
                    dep_cache[parennt]["build_child_nodes"] = {}
                end

                dep_cache[parent]["build_child_nodes"][style] =
                dep_cache[parent]["build_child_nodes"][style] or {}

                dep_cache[parent]["build_child_nodes"][style][key] = true

                need_to_build = parent_need_to_build
            end

        end

        need_to_build = need_to_build or child_need_to_build or subfix_need_to_build

    end

    dep_list[key].dep_added = true
    dep_list[key].need_to_build = need_to_build

    return need_to_build

end

---@Param: pics_list
local function build_dep_tree(root_dir, cur_dir, style, pics_list, dep_list, subfix_cache)

    assert(type(root_dir) == "string")
    assert(type(style) == "string")
    assert(type(pics_list) == "table")
    assert(type(dep_list) == "table")

    local dep_cache = read_dep_cache(root_dir)
    local subfix_cache = read_subfix_cache(root_dir)

    local updated_subfix_files = {}

    local pdf_fd
    local need_to_build = false

    for key, file in pairs(pics_list) do

        if not dep_list[key] then
            pics_list[key] = nil
            tb_log(
                "warn",
                "tex file doesn't exist: "
                .. key
                .. ".tex"
            )
            goto continue
        end

        pdf_fd = io.open(
            dep_list[key].parent_dir
            .. "/"
            .. style
            .. "/"
            .. key
            .. ".pdf",
            "r"
        )

        if pdf_fd then
            pdf_fd:close()
        else
            need_to_build = true
        end

        if build_dep_for_file(
            root_dir, cur_dir, key, style, dep_list, dep_cache, subfix_cache, updated_subfix_files
        ) then
            need_to_build = true
            tb_log("log", "Need to build: " .. key)
        end

        if need_to_build then
            need_to_build = false
            dep_cache[key].style = style
        else
            if not dep_cache[key].style
                or dep_cache[key].style ~= style then

                os.execute(
                    "cp \""
                    .. dep_list[key].parent_dir
                    .. "/"
                    .. style
                    .. "/"
                    .. key
                    .. ".pdf\" \""
                    .. dep_list[key].parent_dir
                    .. "/"
                    .. key
                    .. ".pdf\""
                )

                dep_cache[key].style = style
            end
            pics_list[key] = nil
        end

        ::continue::
    end

    return dep_cache, subfix_cache

end

local function gen_standalone_main(root_dir, main_file, standalone_main)

    local main_file_source = read_file(
        root_dir
        .. "/"
        .. main_file
    )

    local standalone_source = main_file_source:gsub(
        ".*\\documentclass[ \n\t]*%[[^%]]-%][ \n\t]*{[^}]-}(.-\\begin{document}).*",
        "\\documentclass[tikz]{standalone}%1\n\\end{document}\n"
    )

    local fd = io.open(
        root_dir
        .. "/"
        .. standalone_main
        .. ".tex",
        "w"
    )

    assert(fd,
        "gen_standalone_main: failed to open standalone main file"
    )

    fd:write(standalone_source)
    fd:close()

end

local function gen_standalone_sub(root_dir, cur_dir, lconfig,
    pics_list, dep_list, dep_cache)

    local function add_files(fd, pics_list)

        local file_source

        for key in pairs(pics_list) do
            if dep_list[key].file_added then
                goto continue
            end

            add_files(fd, dep_cache[key].parent_nodes)
            file_source = read_file(
                dep_list[key].parent_dir
                .. "/"
                .. key
                .. ".tex"
            )

            fd:write(file_source)
            fd:write("\n\n")

            dep_list[key].file_added = true

            ::continue::
        end
    end

    local fd

    local file_order = {}
    local file_source

    fd = io.open(
        cur_dir
        .. "/"
        .. lconfig["standalone.sub"]
        .. ".tex",
        "w"
    )

    assert(fd,
        "gen_standalone_sub: failed to open file"
    )


    fd:write(
        "\\documentclass ["
        .. root_dir .. "/" .. lconfig["standalone.main"]
        .. "] {subfiles}\n\n"
    )

    for key in pairs(pics_list) do

        -- TODO: I think it's almost impossible to add the the \subfix
        -- for sub pics because the way circuitikz implements them.
        -- So need to find a way to do this. For now \subfix will work for
        -- end pics.
        add_files(fd, dep_cache[key].parent_nodes)

        file_order[#file_order + 1] = key
        dep_list[key].file_added = true

    end

    fd:write("\\begin{document}\n\n")
    local rel_epic_parent

    for _, key in ipairs(file_order) do

        -- we need to add \renewcommand\subfix[1]{new_dir} before every end pic.
        -- the new_dir will be different depending on the end pic and the cur_dir.

        rel_epic_parent = dep_list[key].parent_dir:gsub("^" .. cur_dir .. "/", "")
        rel_epic_parent = rel_epic_parent:gsub("/-[^/]*$", "")

        if rel_epic_parent ~= "" then
            rel_epic_parent =  rel_epic_parent .. "/"
        end

        fd:write("\\renewcommand\\subfix[1]{" .. rel_epic_parent .. "#1}\n\n")

        file_source = read_file(
            dep_list[key].parent_dir
            .. "/"
            .. key
            .. ".tex"
        )

        fd:write(file_source)
        fd:write("\n\n")

    end

    fd:write("\\end{document}\n\n")

    fd:close()

    return file_order

end

local function build_pics(cur_dir, lconfig, file_order, dep_list)

    assert(type(cur_dir) == "string")
    assert(type(lconfig) == "table")
    assert(type(dep_list) == "table")
    assert(type(file_order) == "table")

    os.execute(
        "mkdir \""
        .. cur_dir .. "/".. lconfig["standalone.tmpdir"] .. "\" > /dev/null 2>&1"
    )

    local exit_stat = os.execute(
        "pdflatex -halt-on-error -shell-escape -output-directory \""
        -- "pdflatex --enable-write18 --main-memory=70000000 --extra-mem-bot=10000000 --extra-mem-top=10000000 --synctex=1 -halt-on-error -shell-escape -output-directory \""
        .. lconfig["standalone.tmpdir"]
        .. "\" \""
        .. lconfig["standalone.sub"]
        .. ".tex\""
    )

    assert(exit_stat,
        "build_pics: pdflatex failed miserably."
    )

    local bg_process = {}
    local cur_idx = 0
    local key
    local idx

    for batch = 1, #file_order / 8 do
        for batch_idx = 1, 8 do
            idx = cur_idx + batch_idx
            key = file_order[idx]

            os.execute(
                "mkdir \""
                .. dep_list[key].parent_dir .. "/".. lconfig["style"]
                .. "\" > /dev/null 2>&1"
            )

            bg_process[batch_idx] = io.popen(
                "pdftk \""
                .. cur_dir
                .. "/"
                .. lconfig["standalone.tmpdir"]
                .. "/"
                .. lconfig["standalone.sub"]
                .. ".pdf\" cat "
                .. tostring(idx)
                .. "-"
                .. tostring(idx)
                .. " output \""
                .. dep_list[key].parent_dir
                .. "/"
                .. lconfig["style"]
                .. "/"
                .. key
                .. ".pdf\" &"
            )
        end

        for batch_idx = 1, 8 do
            bg_process[batch_idx]:read("a")
            bg_process[batch_idx]:close()
        end

        cur_idx = cur_idx + 8
    end

    for batch_idx = 1, #file_order % 8 do
        idx = cur_idx + batch_idx
        key = file_order[idx]

        os.execute(
            "mkdir \""
            .. dep_list[key].parent_dir .. "/".. lconfig["style"]
            .. "\" > /dev/null 2>&1"
        )

        bg_process[batch_idx] = io.popen(
            "pdftk \""
            .. cur_dir
            .. "/"
            .. lconfig["standalone.tmpdir"]
            .. "/"
            .. lconfig["standalone.sub"]
            .. ".pdf\" cat "
            .. tostring(idx)
            .. "-"
            .. tostring(idx)
            .. " output \""
            .. dep_list[key].parent_dir
            .. "/"
            .. lconfig["style"]
            .. "/"
            .. key
            .. ".pdf\" &"
        )
    end

    for batch_idx = 1, #file_order % 8 do
        bg_process[batch_idx]:read("a")
        bg_process[batch_idx]:close()
    end

end

local function link_build_files(style, file_order, dep_list)

    for _, key in ipairs(file_order) do
        os.execute(
            "cp \""
            .. dep_list[key].parent_dir
            .. "/"
            .. style
            .. "/"
            .. key
            .. ".pdf\" \""
            .. dep_list[key].parent_dir
            .. "/"
            .. key
            .. ".pdf\""
        )

    end
end

local function clean_standalone_files(lconfig, root_dir, cur_dir)

    assert(type(root_dir) == "string")
    assert(type(cur_dir) == "string")
    assert(type(lconfig) == "table")

    assert(root_dir ~= "")
    assert(cur_dir ~= "")

    os.execute(
        "rm -r \""
        .. root_dir
        .. "/"
        .. lconfig["standalone.main"]
        .. ".tex\" \""
        .. cur_dir
        .. "/"
        .. lconfig["standalone.sub"]
        .. ".tex\" \""
        .. cur_dir
        .. "/"
        .. lconfig["standalone.tmpdir"]
        .. "\""
    )

end

local function gen_disc_standalone_sub(root_dir, lconfig, epic_list, dep_list)

    local fd

    fd = io.open(
        lconfig["standalone.sub"]
        .. ".tex",
        "w"
    )

    assert(fd, "gen_disc_standalone_sub: could'nt open file for standalone sub")

    fd:write(
        "\\documentclass ["
        .. root_dir .. "/" .. lconfig["standalone.main"]
        .. "] {subfiles}\n\n"
        .. "\\begin{document}\n\n"
    )

    for _, pic in ipairs(epic_list) do

        fd:write(
            "\\standaloneconfig{margin = {"
            .. pic.margin
            .. "}}\n"
            .. "\\begin{tikzpicture}\n"
            .. "\\node [inner sep = 0pt] {"
            .. "\\includegraphics{"
            .. dep_list[pic.file_basename].parent_dir
            .. "/"
            .. lconfig["style"]
            .. "/"
            .. pic.file_basename
            .. ".pdf}};\n"
            .. "\\end{tikzpicture}\n\n"
        )
    end

    fd:write(
        "\\end{document}\n"
    )

    fd:close()

end

local function build_disc_pics(lconfig, epic_list, output_dir)

    local exit_stat

    os.execute(
        "mkdir \""
        .. lconfig["standalone.tmpdir"] .. "\" > /dev/null 2>&1"
    )

    if output_dir then

        exit_stat = os.execute(
            "mkdir \""
            .. output_dir .. "\" -p > /dev/null 2>&1"
        )

        assert(exit_stat,
            "build_disc_pics: couldn't create " .. output_dir
        )

        output_dir = output_dir .. "/"
    else
        output_dir = ""
    end

    exit_stat = os.execute(
        "pdflatex -halt-on-error -shell-escape -output-directory \""
        -- "pdflatex --enable-write18 --main-memory=70000000 --extra-mem-bot=10000000 --extra-mem-top=10000000 --synctex=1 -halt-on-error -shell-escape -output-directory \""
        .. lconfig["standalone.tmpdir"]
        .. "\" \""
        .. lconfig["standalone.sub"]
        .. ".tex\""
    )

    assert(exit_stat,
        "build_disc_pics: pdflatex failed miserably."
    )

    for idx, pic in ipairs(epic_list) do

        os.execute(
            "pdftk \""
            .. lconfig["standalone.tmpdir"]
            .. "/"
            .. lconfig["standalone.sub"]
            .. ".pdf\" cat "
            .. tostring(idx)
            .. "-"
            .. tostring(idx)
            .. " output \""
            -- the "/" will be appended to the actual output_dir, above
            .. output_dir
            .. pic.file_basename
            .. "-"
            .. lconfig["style"]
            .. ".pdf\""
        )

    end

end

local function loop_tbl(tbl)

    local itm = {
        idx = 0,
        val = nil
    }

    local mt = {
        __index = {
            peek_next = function ()
                return tbl[itm.idx + 1]
            end,
            skip_next = function ()
                itm.idx = itm.idx + 1
            end,
        }
    }

    setmetatable(itm, mt)

    return function()
        itm.idx = itm.idx + 1
        itm.val = tbl[itm.idx]
        if not itm.val then return nil end
        return itm
    end

end

local function usage(exe)

    local exe_name

    if exe:match("^/") then
        exe_name = exe:gsub("^.-/?([%w-_]-)$", "%1")
    else
        exe_name = exe
    end

    io.write (
        "usage: "
        .. exe_name
        .. " [options] [input file]\n\n"
        .. "    options:\n"
        .. "    --style              style name to use, default value is 'default'.\n"
        .. "                         this overrides --style-file and --style-macro.\n"
        .. "    --style-file         file to read the style from.\n"
        .. "    --style-macro        macro to look for in the 'style file', and takes\n"
        .. "                         the first argument to the macro as the 'style'\n"
        .. "                         [NOTE]: style can't contain any newlines or \n"
        .. "                         forward slashes, if the exist they will be \n"
        .. "                         stripped.\n"
        .. "    --style-root-path    style file will be relative path from root dir.\n"
        .. "\n"
        .. "    --touch-file         touches that file if we needed to build anything.\n"
        .. "    --dry-run            produces the standalone files and exits.\n"
    )

    os.exit()

end

-- Param cur_dir string? needs to the absolute path
local function get_root_dir_from_dir(cur_dir)

    local parent_dir
    local stat = os.execute("[ -d \"" .. cur_dir .. "/.lunatikz\" ]")

    parent_dir = cur_dir:gsub("(.*)/.-$", "%1")

    -- print(stat)
    -- print(cur_dir)
    -- print(parent_dir)

    if stat then
        return cur_dir
    elseif cur_dir ~= "" then
        return get_root_dir_from_dir(parent_dir)
    else
        return nil
    end

end

local function read_config(file_path)

    local config_file = io.open(file_path, "r")
    local config = nil

    if config_file then
        config_file:close()
        config = dofile(file_path)
    end

    return config or {}

end

local function parse_args_init(args_iter)

    local stat
    local arg_config = {}

    for arg in args_iter do
        stat = os.execute("mkdir \"" .. arg.val .. "\" > /dev/null 2>&1")

        arg_config[#arg_config + 1] = arg.val
    end

    return arg_config

end

local function parse_args_build(args_iter, root_dir, pics_directory)

    local arg_config = {}
    local val
    local tmp_fd
    local next_arg
    local rel_path
    local abs_path
    local in_root_dir

    local in_pics_directory

    local pics_list = {}
    local file_list = {}
    arg_config.file_list = file_list
    arg_config.pics_list = pics_list

    local rel_parent_dir
    local abs_parent_dir
    local file_name
    local file_basename
    local file_source

    local margin = "0pt"

    for arg in args_iter do

        val = arg.val

        if not val:match("^%-%-") then

            assert(check_file(val),
                "parse_args_build: " .. val .. "file does not exist."
            )

            tmp_fd = io.popen(
                "readlink -e \"" .. val .. "\""
            )
            assert(tmp_fd)

            abs_path = tmp_fd:read("a"):gsub("\n", "")

            -- stripping root directory
            in_root_dir, rel_path = abs_path:match("^(" .. root_dir .. ")/?(.*)$")

            assert(in_root_dir,
                "parse_args_build: " .. abs_path .. " file is outside of root directory"
            )

            rel_parent_dir, file_name = rel_path:match("^(/?.-)/-([%w%.-_ ]+)$")

            file_basename = file_name:match("(.-)%.[%w-_]+ *$")
            assert(file_basename, "File basename is empty")

            abs_parent_dir = abs_path:match("^(/?.-)/-([%w%.-_ ]+)$")

            in_pics_directory = rel_parent_dir:match(pics_directory .. "$")

            if in_pics_directory then

                file_source = read_file(abs_path)

                if file_source
                    :match("\\begin{tikzpicture}.-\\end{tikzpicture}") then
                    pics_list[#pics_list + 1] = {
                        file_basename = file_basename,
                        margin = margin
                    }

                else
                    tb_log("warn",
                        "parse_args_build: " .. abs_path .. " file does not contains"
                        .. " a valid tikzpicture, therefore skipping"
                    )
                end

            else
                file_list[#file_list + 1] = {
                    abs_parent_dir = abs_parent_dir,
                    file_name = file_name
                }
            end

        elseif val == "--output-dir" then

            next_arg = arg.peek_next()

            assert(next_arg,
                "parse_args_build: --output-dir takes a path to the output directory"
            )

            arg_config.output_dir = next_arg

            arg.skip_next()
        elseif val == "--dry-run" then
            arg_config.dry_run = true
        elseif val == "--margin" then
            next_arg = arg.peek_next()

            assert(next_arg,
                "parse_args_build: --margin takes an argument"
            )

            margin = next_arg

            arg.skip_next()
        end
    end

    return arg_config

end

local function parse_args_config(args_iter)

    local val
    local arg_config = {}
    local nextarg

    for arg in args_iter do

        val = arg.val

        if val == "--global" then
            arg_config.global = true
        elseif val == "--clear" then
            arg_config.clear = true
        elseif val == "pics.directory" then
            nextarg = arg.peek_next()
            if nextarg then
                -- TODO: nextarg could be an empty string
                arg_config["pics.directory"] = nextarg:gsub("[/\n]", "")
                arg.skip_next()
            else
                assert(arg_config.clear,
                    "parse_args_config: pics.directory takes an argument"
                )
            end
        elseif val == "pics.skip" then
            arg_config["pics.skip"] = true
        elseif val == "margin" then
            nextarg = arg.peek_next()
            if nextarg then
                arg_config["margin"] = nextarg:gsub("[/\n]", "")
                arg.skip_next()
            else
                assert(arg_config.clear,
                    "parse_args_config: margin takes an argument"
                )
            end
        elseif val == "style" then
            nextarg = arg.peek_next()
            if nextarg then
                arg_config["style"] = nextarg:gsub("[/\n]", "")
                arg.skip_next()
            else
                assert(arg_config.clear,
                    "parse_args_config: style takes an argument"
                )
            end
        elseif val == "style.file" then
            nextarg = arg.peek_next()
            if nextarg then
                arg_config["style.file"] = nextarg:gsub("[\n]", "")
                arg.skip_next()
            else
                assert(arg_config.clear,
                    "parse_args_config: style.file.path takes an argument"
                )
            end
        elseif val == "style.macro" then
            nextarg = arg.peek_next()
            if nextarg then
                arg_config["style.macro"] = nextarg:gsub("[/\n]", "")
                arg.skip_next()
            else
                assert(arg_config.clear,
                    "parse_args_config: style.macro takes an argument"
                )
            end
        elseif val == "style.fromroot" then
            tb_log("warn",
                "parse_args_config: this option currently does nothing, style.file is always\n"
                .. "from the root directory"
            )
            arg_config["style.fromroot"] = true
        elseif val == "touch" then
            arg_config["touch"] = true
        elseif val == "touch.file" then
            nextarg = arg.peek_next()
            if nextarg then
                arg_config["touch.file"] = nextarg:gsub("[/\n]", "")
                arg.skip_next()
            else
                assert(arg_config.clear,
                    "parse_args_config: touch.file takes an argument"
                )
            end
        elseif val == "standalone.main" then
            nextarg = arg.peek_next()
            if nextarg then
                arg_config["standalone.main"] = nextarg:gsub("[/\n]", "")
                arg.skip_next()
            else
                assert(arg_config.clear,
                    "parse_args_config: standalone.main takes an argument"
                )
            end
        elseif val == "standalone.sub" then
            nextarg = arg.peek_next()
            if nextarg then
                arg_config["standalone.sub"] = nextarg:gsub("[/\n]", "")
                arg.skip_next()
            else
                assert(arg_config.clear,
                    "parse_args_config: standalone.sub takes an argument"
                )
            end
        elseif val == "standalone.tmpdir" then
            nextarg = arg.peek_next()
            if nextarg then
                arg_config["standalone.tmpdir"] = nextarg:gsub("[\n]", "")
                arg.skip_next()
            else
                assert(arg_config.clear,
                    "parse_args_config: standalone.tmpdir takes an argument"
                )
            end
        -- elseif val == "watch.list" then
        end

    end

    return arg_config

end

local function parse_args_add_remove(args_iter, root_dir)

    local val
    local arg_config = {}
    local cur_list = "dep_list"
    local stat
    local abs_path
    local tmp_fd

    arg_config["dep_list"] = {}
    arg_config["build_entry"] = {}

    for arg in args_iter do

        val = arg.val

        if not val:match("^%-%-") then

            stat = os.execute("[ -f \"" .. val .. "\" ]")

            assert(stat,
                "parse_args_add_remove: " .. val .. " file doesn't exist, exiting"
            )

            tmp_fd = io.popen(
                "readlink -e \"" .. val .. "\""
            )
            assert(tmp_fd)

            abs_path = tmp_fd:read("a"):gsub("\n", "")
            tmp_fd:close()

            arg_config[cur_list]
            [#arg_config[cur_list] + 1] = abs_path:gsub("^" .. root_dir .. "/", "")

        elseif val == "--gdep-list" then
            cur_list = "dep_list"
        elseif val == "--build-entry" then
            cur_list = "build_entry"
        else
            assert(false,
                "parse_args_add_remove: " .. val .. " unknown option, exiting"
            )
        end
    end

    return arg_config

end

local function lunatikz_init(data)

    local arg_config = parse_args_init(data.args_iter)
    local stat

    if #arg_config == 0 then
        arg_config[1] = data.cur_dir
    end

    for _, dir in ipairs(arg_config) do
        stat = os.execute("[ -d \"" .. dir .. "/.lunatikz\" ]")

        if stat then
            tb_log( "warn",
                "lunatikz_init: " .. dir .. " is already a lunatikz directory.\n"
                .. "Skipping initialization"
            )
            goto continue
        end

        os.execute("mkdir \"" .. dir .. "/.lunatikz\"")

        -- TODO: touch files (config, dep-list, build-entry...)

        ::continue::
    end

end

local function fill_gdep_list(root_dir, dep_list)

    local lmodt_fd
    local abs_parent_dir
    local abs_file_path
    local lmodt

    for key, file in pairs(dep_list) do

        if file.parent_dir == "" then
            abs_parent_dir = root_dir
        else
            abs_parent_dir = root_dir .. "/" .. file.parent_dir
        end

        abs_file_path = abs_parent_dir .. "/" .. key .. ".tex"

        lmodt_fd = io.popen(
            "stat --printf \"%Y\" \""
            .. abs_file_path .. "\""
        )

        assert(lmodt_fd, "fill_gdep_list: popen failed")

        lmodt = lmodt_fd:read("a")

        assert(lmodt ~= "", "fill_gdep_list: stat returned empty string")

        lmodt = tonumber(lmodt)

        dep_list[key].parent_dir = abs_parent_dir
        dep_list[key].lmodt = lmodt

    end

end

local function set_style(root_dir, lconfig)

    if lconfig["style"] ~= "default" then
        return
    end

    if not (lconfig["style.file"] or lconfig["style.macro"]) then
        return
    elseif (lconfig["style.file"] and not lconfig["style.macro"])
        or (not lconfig["style.file"] and lconfig["style.macro"]) then

        tb_log("warn",
            "set_style: Both style.file and style.macro needs to be set inorder\n"
            .. "to set the style from a file.\n"
            .. "To set run    `lunatikz config style.file path/to/file`\n"
            .. "              `lunatikz config style.macro macro without \\`\n"
        )

        return
    end

    local style_source = read_file(
        root_dir .. "/" .. lconfig["style.file"]
    )

    assert(style_source,
        "set_style: couldn't open style.file"
    )

    -- stripping comments
    -- this works, kind of...
    style_source = style_source:gsub("(\\\\)%%[^\n]-\n", "%1\n")
        :gsub("([^\\])%%[^\n]*", "%1")
        :gsub("^%%[^\n]*", "")

    -- returns the first match
    local style = style_source:match(
        "\\" .. lconfig["style.macro"] .. "[ \n\t]*{(.-)}"
    )

    assert(style,
        "set_style: couldn't find style.macro in style.file"
    )

    -- trimming any newlines or backslashes
    lconfig["style"] = style:gsub("[\n\\]", "")

end

local function lunatikz_build(data)

    local arg_config = parse_args_build(
        data.args_iter, data.root_dir, data.lconfig["pics.directory"])

    local file_source
    local parent_dir
    local file_name

    local dep_list = data.dep_list
    local cur_dir = data.cur_dir
    local lconfig = data.lconfig
    local root_dir = data.root_dir
    local build_entry = data.build_entry

    local pics_list = {}
    local dep_cache
    local main_file
    local file_order

    local subfix_cache

    local in_pics_directory = data.cur_dir
        :match(lconfig["pics.directory"] .. "$")

    if #arg_config.file_list == 0
        and #arg_config.pics_list == 0
        and not in_pics_directory then
        file_name = build_entry[cur_dir:gsub("^" .. root_dir .. "/?", "")]
        assert(file_name,
            "lunatikz_build: no arguments are given, and couldn't find an entry for"
            .. " current directory"
        )
        arg_config.file_list[1] = {
            abs_parent_dir = cur_dir,
            file_name = file_name
        }
    elseif in_pics_directory
        and #arg_config.pics_list == 0 then
        assert(false,
            "lunatikz_build: inside `pics.directory` and no arguments"
        )
    end

    set_style(root_dir, lconfig)

    fill_gdep_list(root_dir, dep_list)

    if not lconfig["pics.skip"] then
        data.dep_list = {} -- clearing read dep_list
        get_dep_list_from_dir(data.root_dir, lconfig["pics.directory"], data.dep_list)
    end

    get_pics_list(root_dir, arg_config.file_list, pics_list)

    -- Adding user asked pics to the pics_list
    for _, pic in pairs(arg_config.pics_list) do
        pics_list[pic.file_basename] = true
    end

    -- building dep_cache
    dep_cache, subfix_cache = build_dep_tree(root_dir, cur_dir, lconfig.style, pics_list, dep_list)

    -- write_config("/dev/stdout", subfix_cache)
    --
    -- write_config("/dev/stdout", dep_cache)

    if #arg_config.file_list == 0
        and #arg_config.pics_list > 0 then
        if not build_entry[""] then
            tb_log("warn",
                "Inorder to build tikzpictures as discrete pdf files, you need to tell\n"
                .. "lunatikz, which file is the main file of this project. In order to do\n"
                .. "that run:    `lunatikz add --build-entry path/to/main/file`\n"
                .. "NOTE: This main file should be the one that is in the root directory of\n"
                .. "the project and contains the actual `documentclass`.\n"
            )
        end
    end

    if next(pics_list, nil) then

        main_file = build_entry[""] or get_main_file(root_dir,
            arg_config.file_list[1].abs_parent_dir .. "/" .. arg_config.file_list[1].file_name)

        gen_standalone_main(root_dir, main_file, lconfig["standalone.main"])

        file_order = gen_standalone_sub(root_dir, cur_dir, lconfig,
            pics_list, dep_list, dep_cache)

        if arg_config.dry_run then
            return
        end

        build_pics(cur_dir, lconfig, file_order, dep_list)

        link_build_files(lconfig["style"], file_order, dep_list)

        if lconfig["touch"] then

            local dirs_touched = {}
            local parent_dir

            -- TODO: Maybe find a better way
            for key in pairs(pics_list) do

                parent_dir = dep_list[key].parent_dir

                if dirs_touched[parent_dir] then
                    goto continue
                end

                os.execute(
                    "touch \""
                    .. parent_dir
                    .. "/"
                    .. lconfig["touch.file"]
                    .. "\""
                )

                dirs_touched[parent_dir] = true

                ::continue::
            end
        end

    end

    if #arg_config.pics_list > 0 then

        if not main_file then
            main_file = build_entry[""]
            gen_standalone_main(root_dir, main_file, lconfig["standalone.main"])
        end

        gen_disc_standalone_sub(root_dir, lconfig, arg_config.pics_list, dep_list)

        if arg_config.dry_run then
            return
        end

        build_disc_pics(lconfig, arg_config.pics_list, arg_config.output_dir)

    end

    -- TODO: maybe restructure this a bit.
    if arg_config.dry_run then
        return
    end

    write_config(data.root_dir .. "/.lunatikz/dep_cache", dep_cache)

    write_config(data.root_dir .. "/.lunatikz/subfix_cache", subfix_cache)

    if #arg_config.pics_list > 0
        or next(pics_list, nil) then
        clean_standalone_files(lconfig, root_dir, cur_dir)
    end

end

local function lunatikz_add(data)

    local arg_config = parse_args_add_remove(data.args_iter, data.root_dir)
    local parent_dir
    local file_basename

    -- Adding to dep_list
    for _, file_path in ipairs(arg_config.dep_list) do

        parent_dir, file_basename = file_path:match("^(/?.-)/-([%w%.-_ ]+).tex$")

        data.dep_list[file_basename] = { parent_dir = parent_dir }
    end

    -- Adding to build_entry
    for _, file_path in ipairs(arg_config.build_entry) do

        parent_dir, file_name = file_path:match("^(/?.-)/-([%w%.-_ ]+)$")

        data.build_entry[parent_dir] = file_name
    end

    if #arg_config.dep_list > 0 then
        write_config(data.root_dir .. "/.lunatikz/dep_list", data.dep_list)
    end

    if #arg_config.build_entry > 0 then
        write_config(data.root_dir .. "/.lunatikz/build_entry", data.build_entry)
    end

end

local function lunatikz_remove(data)

    local arg_config = parse_args_add_remove(data.args_iter, data.root_dir)
    local file_name
    local parent_dir

    -- Removing to dep_list
    for _, file_path in ipairs(arg_config.dep_list) do

        parent_dir, file_name = file_path:match("^(/?.-)/-([%w%.-_ ]+).tex$")

        data.dep_list[file_name] = nil
    end

    -- Removing to build_entry
    for _, file_path in ipairs(arg_config.build_entry) do

        parent_dir, file_name = file_path:match("^(/?.-)/-([%w%.-_ ]+)$")

        data.build_entry[parent_dir] = nil
    end

    if #arg_config.dep_list > 0 then
        write_config(data.root_dir .. "/.lunatikz/dep_list", data.dep_list)
    end

    if #arg_config.build_entry > 0 then
        write_config(data.root_dir .. "/.lunatikz/build_entry", data.build_entry)
    end

end

local function lunatikz_config(data)

    local arg_config = parse_args_config(data.args_iter)

    -- TODO: implement a pretty_print() to print the config
    if #data.args == 1 then
        print("----------------------------------")
        for key, val in pairs(data.lconfig) do
            print(key, "", "", val)
        end
        print("----------------------------------")
        return
    elseif #data.args == 2 and arg_config.global then
        print("----------------------------------")
        for key, val in pairs(data.gconfig) do
            print(key, "", "", val)
        end
        print("----------------------------------")
        return
    end

    if arg_config.global then
        if arg_config.clear then
            for _, arg in ipairs(data.args) do
                data.gconfig[arg] = nil
            end
            print("Not yet implemented")
        end
    else
        if arg_config.clear then
            for _, arg in ipairs(data.args) do
                data.lconfig[arg] = nil
            end
        else
            for key, val in pairs(arg_config) do
                data.lconfig[key] = val
            end
        end
        write_config(data.root_dir .. "/.lunatikz/config", data.lconfig)
    end

end

local function lunatikz(args)

    local data = {}

    local tmp_fd = io.popen("pwd")

    if not tmp_fd then return nil end

    data.cur_dir = tmp_fd:read("a"):gsub("\n", "")
    tmp_fd:close()

    -- For termux (Android)
    -- if we are in the internal storage, we need the /storage/emulatec/0/*
    -- path
    tmp_fd = io.popen(
        "readlink -e \"" .. data.cur_dir .. "\""
    )
    assert(tmp_fd)
    data.cur_dir = tmp_fd:read("a"):gsub("\n", "")
    tmp_fd:close()

    data.args_iter = loop_tbl(args)
    local fstarg = data.args_iter()


    -- TODO: need to implement to read and update
    data.gconfig = {}

    data.root_dir = get_root_dir_from_dir(data.cur_dir)

    if not fstarg then usage(args[0]) end

    fstarg = fstarg.val

    data.args = args

    if fstarg == "init" then
        lunatikz_init(data)
        return
    end

    assert(data.root_dir,
        "Current directory is not a lunatikz directory,\n"
        .. "Run `lunatikz init path/to/dir` to initialize the dir as a lunatikz directory"
    )

    -- Reading local config
    data.lconfig = read_config(data.root_dir .. "/.lunatikz/config")

    -- Setting defaults for local config
    setmetatable(data.lconfig, {
        __index = {
            ["pics.directory"] = "tikzpics",
            ["standalone.sub"] = "_standalone_sub",
            ["standalone.main"] = "_standalone_main",
            ["standalone.tmpdir"] = "_standalone_tmp",
            ["pics.skip"] = false,
            ["margin"] = "0pt",
            ["style"] = "default",
            ["style.file"] = nil,
            ["style.macro"] = nil,
            ["style.fromroot"] = false,
            ["touch"] = false,
            ["touch.file"] = "need_to_build",
        }
    })

    if fstarg == "config" then
        lunatikz_config(data)
        return
    end

    -- Reading dependency list
    data.dep_list = read_config(data.root_dir .. "/.lunatikz/dep_list")

    -- Reading build entries
    data.build_entry = read_config(data.root_dir .. "/.lunatikz/build_entry")

    if fstarg == "add" then
        lunatikz_add(data)
    elseif fstarg == "remove" then
        lunatikz_remove(data)
    elseif fstarg == "build" then
        lunatikz_build(data)
    else
        tb_log("warn",
            "lunatikz: " .. fstarg .. " is an unknown subcommand"
        )
    end


    return
end

return lunatikz(arg)
